# TEMA4 PROTOCOALE DE COMUNICATII ANCA-MARIA COLACEL 324CC /
# Client Web. Comunica≈£ie cu REST API. 

**ORGANIZARE**
Implementarea acestei teme a durat aproximativ 2 zile. Mi s-a parut cea mai usoara tema dintre toate cele 4 propuse la aceasta materie. Am pornit cu implementarea de la laboratorul 9, care a fost de mare ajutor in intelegerea notiunilor legate de acest protocol. In cele ce urmeaza voi detalia modul de implementare al temei si gandirea abordata.
Am implementat fisierul client.c in care este implementarea efectiva a temei si am imbunatatit fisierele requests.c si requests.h din scheletul de laborator. Tema mai contine de asemenea si fisierele helpers.c si helpers.h si buffer.c si buffer.h.
Modificarile aduse in requests.c se refera la adaugarea cookiu-urilor, a headerului Authorization precum si crearea functiei compute_delete_request, necesara pentru trimiterea cererii de delete_book.
Liniile suplimentare adaugate sunt conform modului de alcatuire al unei cereri catre server.
In client.c lucrez intr-o bucla infinita in care citesc de la tastatura si interpretez comenzile cerute. Prima comanda este cea de register, care necesita o cerere de tip GET. Citesc de la tastatura userul si parola cu care doresc sa ma inregistrez. Am utilizat o biblioteca numita json-c pentru a-mi creea mai usor un buffer de tip json. Dupa ce citesc cele 2 stringuri verific ca acestea sa nu contina spatii si creez un obiect json si cu functiile speciale json_object_object_add si json_object_new_string introduc in json campurile necesare. Acesta este apoi convertit la char buffer cu functia json_object_to_json_string(json_obj). Urmeaza apoi deschiderea conexiunii, formarea mesajului tip cerere, trimiterea sa si primirea raspunsului de la server. Am printat apoi o confirmare a crearii contului cu succes. Urmeaza comanda de login care este similara, credentialele citite sunt aceleasi si sunt si ele verificate, cererea este de tipul POST. Raspunsul poate contine 2 tipuri de erori, daca credentialele nu se potrivesc sau daca nu exista cont cu acel user. Acestea sunt niste buffere json care trebuiau obtinute din raspunsul primit. Pentru a le putea obtine am realizat parsarea la fel ca la laborator, bazandu-ma pe faptul ca bufferul incepe cu {. Incep prin a salva adresa unde am {, apoi salvez adresa pentru Content-Length si obtin lungimea prin adunarea lungimii stringului "Content-Lengt:" la adresa de start, apoi stiu exact cat are mesajul meu json si avand adresa de start (unde incepe {) pot obtine intreg mesajul. Mai departe verific acest mesaj cu strncmp cu mesajele de eroare care stiu ca ar trebui sa fie primite si printez in consecinta mesaje la consola. Urmeaza apoi sa imi pastrez cookiul de autentificare primit in caz de succes pentru ca este necesar in multe functii care urmeaza dupa aceea. Fac acest lucru in mod asemanator, retin adresa de inceput pentru "Set-Cookie:", gasesc caracterul pentru final /r si cu aceste informatii scot cookiul care ma intereseaza si il pastrez intr-un buffer. Urmeaza apoi comanda enter_library. Aceasta necesita o cerere de tip GET care are ca si parametru cookiul obtinut anterior. Pentru a demonstra ca am acces la biblioteca in urma acestei cereri voi primi un token, pe care mi-l salvez. Acest lucru il fac similar cu strategia de mai sus, caut stringul "token: ", caut si lungimea si salvez datele intr-un buffer.
Mai departe am implementat comanda get_books care foloseste o cerere GET avand ca si parametru si tokenul obtinut anterior pentru a demonstra accesul. Pentru a parsa id-ul si titlul pentru fiecare carte in parte mi-am creat o functie de parsare. Aceasta face strtok pe string-ul ce contine multimea de jsoane folosind o lista de delimitatori, apoi compara tokenul pe rand cu id si title si extrage valorile acestora pentru a fi printate. Urmeaza get_book care citeste si ID-ul unei carti dorite, verific ca e format doar din cifre, fac o cerere de tip GET apoi parsez tipurile de mesaje de eroare si printez texte potrivite la stdout. Pentru a parsa toate campurile jsonului pentru acea carte am creat o alta functie de parsare foarte asemenatoare cu cea de mai sus doar ca iau pe rand toate cele 5 campuri nu doar id si titlu.  La add_book imi citesc toate notiunile necesare despre o carte, creez buffer json si fac cerere POST. Am verificat ca numarul de pagini sa fie format doar din cifre si am printat mesaje pentru aceasta posibilitate si am verificat ca numele autorului sa nu contina cifre. Pentru aceste verificari mi-am creat niste functii auxiliare simple. La delete citesc ID-ul cartii pe care vreau sa o sterg, il verific sa fie numar si folosesc o cerere de tip DELETE. Urmeaza logout care necesita o cerere de tip GET si eliberez memoria pentru cookie si token ca sa nu mai pot avea acces la biblioteca si sa aiba sens delogarea. In final, comanda exit inchide executia aplicatiei.


**ALTE OBSERVATII**
-legat de folosirea bibliotecii json-c, aceasta a fost descarcata folosind comanda sudo apt-get install libjson-c-dev, fisierul makefile este si el completat pentru a compila fisierele mele legand si aceasta biblioteca
-tema a fost interesanta, nu a necesitat multa documentatie suplimentara si a ajutat la o intelegere aprofundata a protocolului HTTP.


**BIBLIOGRAFI**
- laboratorul 9, breaviarul teoretic si rezolvarea exercitiilor
- cursurile aferente protocolului HTTP
- https://en.wikipedia.org/wiki/HTTP
